# 解题思路
刚做了一道链表的递归题，看到这题立马就想到了用递归方式来解。

用递归的框架最大的好处在于**能够控制在进入节点和离开节点的时间做自己想做的事情！**

首先思考如果不是复杂链表，是简单链表，即节点只有`next`指针，如何复制？

在离开节点的时候使用递归函数返回的下一个复制节点，来更新next指针。

很明显更新next指针需要用到下一层的递归信息

**重点**：
如果是复杂链表呢？如何更新`random`指针？

利用下一层递归信息明显失败了！因为我们**要更新的`random`不一定是来源于下一层，而是来自于整个链表！！！**



那么正好！！！根据递归的好处，我们可以选择在进入节点的时间，来存储`random`信息。注意，这里`copy`节点的`random`信息可分解为
- 对应`origin`节点的`random`地址
- 原链表节点和复制链表节点的映射

设`unordered_map<Node*,Node*>dic`,`key`值代表`origin`节点的地址，`value`代表对应的`copy`节点地址

那么有
```
copy->random=dic[origin->random]
```

至此问题可解！

那么注意`timing`啊~也就是时机，嘿嘿：
> 这道题想要在进入节点的时机，做两件事
> 1. `new` `copy`节点，并初始化`value`值
> 2. 建立`origin`到`copy`对应关系，存入哈希表
> 
>在离开节点时做两件事
>1. 更新`copy`节点的`next`指针
>2. 更新`copy`节点的`random`指针


# 返回值
`return dic[head]`


